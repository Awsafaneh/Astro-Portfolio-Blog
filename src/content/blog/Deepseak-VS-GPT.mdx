---
title: Deepseak VS GPT
description: 'New Model in Town '
pubDate: 2025-01-30T19:00:00.000Z
draft: true
authorName: Abdul Rafay
authorAvatar: /IMG-20221105-WA0007.jpg
tags:
  - AI
---

While... While what? Today, we have a new AI model going wild on the internet, and it's called **Deepseak**â€”the new **thinking AI model** thatâ€™s set to change everything! Will it take our jobs? Just kidding. But the future is here, and these new thinking models are truly fascinating. The ability to **think independently** is incredible.

But weâ€™re here for something elseâ€”**which one is better?** By now, weâ€™ve all seen the benchmarks, and they point to **Deepseak (R1)** outperforming **ChatGPT (O1)**. But how much of a difference does this improvement make for us **developers**? And more importantly, how can we **make money** from it? (Because thatâ€™s what capitalists doâ€”but thatâ€™s a topic for another day.)

For now, let's talk about **AI**.

If you havenâ€™t seen the benchmarks yet, check out the image below:\
![image](/BlogImages/deepseak_benchmark.jpg "Benchmark Result")

### So, which AI is better for developers?

To find out, I designed **four tasks**â€”each consisting of two sections:

1. **One focused on coding**
2. **One focused on problem-solving**

Here are the tasks:

#### **Section 1: Code Innovation & Uniqueness**

âœ… **Task 1:**\
Write a function that sorts a list of numbers **without using built-in sorting functions**. The goal is to implement a novel approachâ€”**no classic algorithms** like Merge Sort, Quick Sort, or Bubble Sort.

âœ… **Task 2:**\
Create a function that generates random yet **aesthetically pleasing ASCII art** based on a given keyword (e.g., "mountain," "wave," or "tree"). The output should follow a pattern rather than being completely random.

#### **Section 2: Problem-Solving with Constraints**

âœ… **Task 3:**\
Design an algorithm to find the **shortest path in a maze**. The maze is represented by a **2D array**, where `0` represents an open path and `1` represents a wall.

* The AI **must not** simply implement BFS or Dijkstraâ€™s Algorithmâ€”it needs to come up with a unique approach.

âœ… **Task 4:**\
Write a function that generates **efficiently compressible JSON** while maintaining readability. The AI should consider:

* Reducing redundant keys
* Using data structures that aid compression
* Preserving human readability

### **Base Rules**

Before we begin, Iâ€™m using the **free version** of both AI modelsâ€”**OpenAI Free Access** and **Deepseak Free Access**â€”no paid versions. Plus, Iâ€™ll also be asking about their **thought processes** along the way.

Letâ€™s see which AI comes out on top! ðŸš€

## ChatGPT

Here are the results

### Task 01:

```py
import time
import random

# Custom function to find the minimum value
def find_min(arr):
    min_val = arr[0]
    for num in arr:
        if num < min_val:
            min_val = num
    return min_val

# Custom function to find the maximum value
def find_max(arr):
    max_val = arr[0]
    for num in arr:
        if num > max_val:
            max_val = num
    return max_val

# Histogram Sort (without built-in functions)
def histogram_sort(arr):
    if not arr or len(arr) == 1:
        return

    # Step 1: Find min and max manually
    min_val = find_min(arr)
    max_val = find_max(arr)

    # Step 2: Create a histogram (frequency array)
    size = max_val - min_val + 1
    histogram = [0] * size  # Zero-initialized list

    for num in arr:
        histogram[num - min_val] += 1

    # Step 3: Reconstruct sorted array
    index = 0
    i = 0
    while i < size:
        while histogram[i] > 0:
            arr[index] = i + min_val
            index += 1
            histogram[i] -= 1
        i += 1

# Custom function to generate a list of random numbers
def generate_random_list(size, min_val, max_val):
    arr = [0] * size
    for i in range(size):
        arr[i] = random.randint(min_val, max_val)
    return arr

# Benchmarking function
def benchmark_sorting(size, min_val, max_val):
    arr1 = generate_random_list(size, min_val, max_val)
    arr2 = [arr1[i] for i in range(len(arr1))]  # Manual copy (no built-in functions)

    # Measure Histogram Sort
    start1 = time.time()
    histogram_sort(arr1)
    end1 = time.time()

    # Measure Custom Manual Sorting (Simulated Built-in sort)
    start2 = time.time()
    for i in range(len(arr2)):
        for j in range(i + 1, len(arr2)):
            if arr2[i] > arr2[j]:  # Swap if needed
                arr2[i], arr2[j] = arr2[j], arr2[i]
    end2 = time.time()

    # Output results
    print("Histogram Sort Time: ", (end1 - start1) * 1e6, "microseconds")
    print("Manual Sorting (Selection Sort) Time: ", (end2 - start2) * 1e6, "microseconds")

# Run benchmark
random.seed(0)  # Ensure reproducibility
benchmark_sorting(10000, 0, 1000)
```
